library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use ieee.numeric_std.all;  
 
 -- All computations are handled in 2's complement fixed point using 1 sign bit, 1 integer bit and 14 fractional bits
 -- A scaling factor of 2^14 is therefore used between the actual values and the internally handled values
 
entity CORDIC_time is
GENERIC(
		ADDR_LENGTH : natural 	:= 4;
		DATA_WIDTH	: natural	:= 16);
    Port (
		 i_x	   : IN  STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0'); -- Input x
		 i_y	   : IN  STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0'); -- Input y
		 o_z	   : OUT STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0'); -- Output z
		 o_y     : OUT STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0'); -- Output y
		 i_enable_cordic : IN  STD_LOGIC := '0';
		 o_done  : OUT STD_LOGIC := '0' ;
		 clk_in  : IN STD_LOGIC := '0';
		 state_LED : OUT STD_LOGIC_VECTOR(3 downto 0):=(others => '0'); 
		 LUT_TEST : OUT STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0')
		 ); 

end CORDIC_time;
 
architecture behave of CORDIC_time is


------------- Control signals ----------
  signal var_regi 		 : STD_LOGIC_VECTOR(1 downto 0):= "00";
  signal var_done 		 : STD_LOGIC:= '0';    
------------- \Control signals ----------
  -- Signals for CORdic
  signal i_xn0           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  signal i_xn1           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 

  signal i_yn0           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  signal i_yn1           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  
  signal i_zn0           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  signal i_zn1           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  
  signal i_xnTMP           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 
  signal i_ynTMP           : STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= "0000000000000000"; 

  
  -----------bit_shift signals--------
  signal i_bitshift_x  	: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_bitshift_y  	: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  
  signal o_bitshift_x 	: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  signal o_bitshift_y 	: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  
  signal c_shiftlength  : STD_LOGIC_VECTOR((ADDR_LENGTH-1) downto 0):= (others => '0');
-----------/bit_shift signals--------  

-----------sign_inverter signals--------
  signal i_SI_x			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_SI_y			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_SI_z			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  
  signal o_SI_x			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);  
  signal o_SI_y			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0); 
  signal o_SI_z			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  
  signal i_SI_control   : STD_LOGIC_VECTOR(1 downto 0) := "00";
-----------/sign_inverter signals--------


-----------LUT signals--------
  signal i_LUT_addr     : STD_LOGIC_VECTOR((ADDR_LENGTH-1) downto 0):= (others => '0'); 
  signal i_mem_enable   : STD_LOGIC:= '0';
  signal o_LUT 			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  
  signal i_LUT_addr_X     : STD_LOGIC_VECTOR((ADDR_LENGTH-1) downto 0):= (others => '0'); 
  signal i_mem_enable_X   : STD_LOGIC:= '0';
  signal o_LUT_X 			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  
  signal i_LUT_addr_Y     : STD_LOGIC_VECTOR((ADDR_LENGTH-1) downto 0):= (others => '0'); 
  signal i_mem_enable_Y   : STD_LOGIC:= '0';
  signal o_LUT_Y 			: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  
  signal LUT_COUNTER : integer:=0;
-----------/LUT signals--------

-----------signed_adder signals--------
  signal i_adder_a_x		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_adder_a_y		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_adder_a_z		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');

  signal i_adder_b_x		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_adder_b_y		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  signal i_adder_b_z		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0):= (others => '0');
  
  signal o_adder_x		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  signal o_adder_y		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
  signal o_adder_z		: STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);  
-----------/signed_adder signals--------  
  
--------Signals for iteration_counter---
  signal clk : std_logic := '0';
  signal clk_2 : std_logic := '0';
  signal o_iteration_count : integer range 0 to DATA_WIDTH-1 := 0;
  signal i_reset : std_logic := '0';
  signal i_enable : std_logic := '0';
-------/Signals for iteration_counter---

-------Signals for clock divider---
--Inputs
--signal clk : std_logic := '0';
signal reset : std_logic := '0';
 
--Outputs
signal clock_out : std_logic;
-------/Signals for clock divider---

 
  -- Signals debug
  type state_type is (run, regi, setup, done);
  signal state : state_type := setup;
  
  signal db_x_int : integer;
  signal db_y_int : integer;
  signal db_z_int : integer; 


--------- Components-----------  

COMPONENT Clock_Divider is
PORT(
clk : IN std_logic;
reset : IN std_logic;
clock_out : OUT std_logic
);
END COMPONENT Clock_Divider;


component bit_shift is
	generic(	DATA_WIDTH 	: natural;
			   ADDR_LENGTH : natural
				);
	Port (  i_bitshift  	 : IN  std_logic_vector((DATA_WIDTH-1) downto 0);
			  o_bitshift 	 : OUT std_logic_vector((DATA_WIDTH-1) downto 0);
			  c_shiftlength : IN  STD_LOGIC_VECTOR((ADDR_LENGTH-1) downto 0) -- 2^4 = 16, sÃ¥ man har mulighed for at bifshifte up til 16 gange
			);
end component bit_shift;

component sign_inverter is
	generic(	DATA_WIDTH : natural
				);
	Port (  i_SI  	      : IN  STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
			  o_SI 	      : OUT STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
			  i_SI_control	: IN  STD_LOGIC_VECTOR(1 downto 0)
			);
end component sign_inverter;

component LUT_16 is
	Port ( i_LUT_addr    : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
          i_mem_enable  : IN STD_LOGIC;
          o_LUT         : OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
			);
end component LUT_16;

component LUT_X is
	Port ( i_LUT_addr_X    : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
          i_mem_enable_X  : IN STD_LOGIC;
          o_LUT_X         : OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
			);
end component LUT_X;

component LUT_Y is
	Port ( i_LUT_addr_Y    : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
          i_mem_enable_Y  : IN STD_LOGIC;
          o_LUT_Y         : OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
			);
end component LUT_Y;

component signed_adder is
	generic(	DATA_WIDTH : natural
				);
	port(	i_adder_a	   : in STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
			i_adder_b	   : in STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0);
			o_adder 			: out STD_LOGIC_VECTOR((DATA_WIDTH-1) downto 0)
				);
end component signed_adder;

component iteration_counter is
	Port (
		clk		 				  : in std_logic;
		i_reset	  				  : in std_logic;
		i_enable	  				  : in std_logic;
		o_iteration_count	     : out integer range 0 to 31
	);
end component iteration_counter;
--------- /Components----------

begin
   
----------- Map----------
-----------clock divider-------- 
	clock_divider_x : Clock_Divider
    port map (
      clk     => clk_2,
		reset 		=> reset,
		clock_out	=> clock_out
      );
-----------/clock divider--------   

-----------bit_shift signals-------- 
  bit_shift_INST_x : bit_shift
 	 generic map (DATA_WIDTH => DATA_WIDTH,
					  ADDR_LENGTH => ADDR_LENGTH) 
    port map (
      i_bitshift     => i_bitshift_x,
		o_bitshift 		=> o_bitshift_x,
		c_shiftlength	=> c_shiftlength
      );
		
	bit_shift_INST_y : bit_shift
 	 generic map (DATA_WIDTH => DATA_WIDTH,
					  ADDR_LENGTH => ADDR_LENGTH) 
    port map (
      i_bitshift     => i_bitshift_y,
		o_bitshift 		=> o_bitshift_y,
		c_shiftlength	=> c_shiftlength
      );
-----------/bit_shift signals--------   
 
-----------sign_inverter signals--------   
	sign_inverter_INST_x : sign_inverter
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_SI    			=> i_SI_x,
		o_SI 				=> o_SI_x,
		i_SI_control	=> i_SI_control
      );
		
	sign_inverter_INST_y : sign_inverter
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_SI    			=> i_SI_y,
		o_SI 				=> o_SI_y,
		i_SI_control	=> i_SI_control
      );
		
	sign_inverter_INST_z : sign_inverter
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_SI    			=> i_SI_z,
		o_SI 				=> o_SI_z,
		i_SI_control	=> i_SI_control
      );
-----------/sign_inverter signals--------
		
-----------LUT signals--------
   LUT_16_INST : LUT_16
    port map (
      i_LUT_addr    	=> i_LUT_addr,
		i_mem_enable 	=> i_mem_enable,
		o_LUT				=> o_LUT
      );
		
	LUT_X_INST : LUT_X
    port map (
      i_LUT_addr_X    	=> i_LUT_addr_X,
		i_mem_enable_X 	=> i_mem_enable_X,
		o_LUT_X				=> o_LUT_X
      );
		
	LUT_Y_INST : LUT_Y
    port map (
      i_LUT_addr_Y    	=> i_LUT_addr_Y,
		i_mem_enable_Y 	=> i_mem_enable_Y,
		o_LUT_Y				=> o_LUT_Y
      );
-----------/LUT signals--------
		
-----------signed_adder signals--------
   Adder_x : signed_adder
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_adder_a    	=> i_adder_a_x,
		i_adder_b 		=> i_adder_b_x,
		o_adder			=> o_adder_x
      );	
		
   Adder_y : signed_adder
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_adder_a    	=> i_adder_a_y,
		i_adder_b 		=> i_adder_b_y,
		o_adder			=> o_adder_y
      );		
		
   Adder_z : signed_adder
	 generic map (DATA_WIDTH => DATA_WIDTH)	
    port map (
      i_adder_a    	=> i_adder_a_z,
		i_adder_b 		=> i_adder_b_z,
		o_adder			=> o_adder_z
      );
-----------/signed_adder signals--------	

	 
	 iteration_counter_INST : iteration_counter
	 port map (
	 clk						=> clock_out,
	 i_reset					=> i_reset,
	 i_enable				=> i_enable,
	 o_iteration_count 	=> o_iteration_count
	 );
-----------/Map----------	

--process is
--begin
--	clk_2 <= not clk_2;
--	wait for 2 ns;
	
--end process;


-- Process for calculating arctangent using CORDIC  
  process(clock_out) is
  begin
		if(rising_edge(clock_out)) then
			case state is              
				when setup =>           --  This case is responsible for initializing the signals used     					
					state_LED(0) <= '1';
					state_LED(1) <= '0';
					state_LED(2) <= '0';
					state_LED(3) <= '0';
					i_mem_enable_X <= '1';	-- Reads the current input from LUT X and Y
					i_mem_enable_Y <= '1';
					i_LUT_addr_X <= std_logic_vector(to_unsigned(LUT_COUNTER,ADDR_LENGTH));
					i_LUT_addr_Y <= std_logic_vector(to_unsigned(LUT_COUNTER,ADDR_LENGTH));
					i_reset <= '1';      -- Once this signal goes high, the iteration count is reset
					LUT_TEST <= O_LUT_Y; -- Sends the current output of the LUT_Y to the LED's on the FPGA board
					var_done <= '0';       -- Tells that the computation is not finished 
					
					if i_enable_cordic = '0' then  -- Once this signal goes high, the CORDIC algorithm starts
						var_regi <= "00";	-- Set it so the register values does not change				
						state <= run;
					else
						var_regi <= "01"; -- Set the input to the CORDIC algorithm into the register i_xn0 and i_yn0. Also set i_zn0 to 0.
					end if;
					
					
				when run =>           --  This case is responsible for computing the bitshifts
				
					var_regi <= "10";  -- Save the calculated value into the register
					
				   i_reset <= '0';  -- Allows the iteration counter to count up
					i_mem_enable_X <= '0';
					i_mem_enable_Y <= '0';
					i_mem_enable <= '1';      -- Once this signal goes high, the address of the LUt entry is incremented by 1
					
					i_enable <= '1';     --  Increments the iteration counter by 1					
					state <= regi;
					
					state_LED(0) <= '0';
					state_LED(1) <= '1';
					state_LED(2) <= '0';
					state_LED(3) <= '0';
					
				when regi =>            --  This case is responsible for storing the contents of the adders in the correct registers, 
				                        --  aswell as stopping the algorithm when MAX iterations has been reached

					var_regi <= "00";       -- Set the output values into the signals i_xn0, i_yn0 and i_zn0
					
					-------------- DEBUG SIGNALS ----------------------
					db_x_int <= to_integer(signed(o_adder_x));
					db_y_int <= to_integer(signed(o_adder_y));
					db_z_int <= to_integer(signed(o_adder_z));				
					-------------- \DEBUG SIGNALS ----------------------
					
					i_mem_enable <= '0';  -- Set the input low, as a rising edge trigger a read from the lUT
					
					i_enable <= '0';      -- Set the i_enable low , as a rising edge trigger an increment for the counter
					
					
					
					if o_iteration_count = 14 then
						state <= done;
					else
						state <= run;
					end if;
					
					state_LED(0) <= '0';
					state_LED(1) <= '0';
					state_LED(2) <= '1';
					state_LED(3) <= '0';
					
				when done =>        -- Go back to the setup state and wait for a new input

					if LUT_COUNTER > 15 then	-- Make sure the LUT-address do not overflow
						LUT_COUNTER <= 0;
					else
						LUT_COUNTER <= LUT_COUNTER+1;
					end if;
					var_regi <= "00";  -- Set it so the register values does not change
					
					var_done <= '1';   -- Outputs a signal showing that the computations has finished
										  -- Also sets the final values to the output ports
					
					i_reset <= '1';      -- Once this signal goes high, the iteration count is reset
					
					-------------- DEBUG SIGNALS ----------------------
					db_x_int <= to_integer(signed(o_adder_x));
					db_y_int <= to_integer(signed(o_adder_y));
					db_z_int <= to_integer(signed(o_adder_z));				
					-------------- \DEBUG SIGNALS ----------------------		
					state_LED(0) <= '0';
					state_LED(1) <= '0';
					state_LED(2) <= '0';
					state_LED(3) <= '1';
					o_z <= o_adder_z; -- FOr debugging

					state <= setup;  
				when others => state <= setup;
			end case;
		end if;
			
  end process;

-----------  RUN -----------
process(clk_2) is
begin
	if(rising_edge(clk_2)) then
----------- bit shift -----------
		if(var_regi = "00") then
			i_bitshift_x <= i_xn0;
			i_bitshift_y <= i_yn0;
		end if;
c_shiftlength <= std_logic_vector(to_unsigned(o_iteration_count,ADDR_LENGTH));
----------- \bit shift -----------

---------------------------------------------------- These lines determine the control signals given to the sign-inverter
		if(var_regi = "00") and (i_yn0 = i_yn1) then
			i_SI_control(1) <= '1';
		elsif (var_regi = "00") and (i_yn0 /= i_yn1) then
			i_SI_control(1) <= '0';
		end if;

		if(var_regi = "00") then
			i_SI_control(0) 	   <= not i_yn0(DATA_WIDTH-1) ;
		end if;

-----------------------------------------------------------

----------- LUT addr -----------
i_LUT_addr <= std_logic_vector(to_unsigned(o_iteration_count,ADDR_LENGTH));

----------- \LUT addr -----------

----------- sign inverter -----------
i_SI_x  				<= o_bitshift_x;
i_SI_y  				<= o_bitshift_y;
i_SI_z  				<= o_LUT;
----------- \sign inverter -----------

----------- signed adder -----------

		if(var_regi = "00") then
			i_adder_a_x <= i_xn0;
			i_adder_a_y <= i_yn0;
			i_adder_a_z <= i_zn0;
		end if;
	
i_adder_b_x <= not o_SI_y + 1;

i_adder_b_y <= o_SI_x;

i_adder_b_z <= not o_SI_z + 1;
----------- \signed adder -----------

----------- \RUN -----------

------------ Save to regi ---------

	if(var_regi = "01") then
		i_xn0 <= O_LUT_X;
		i_yn0 <= O_LUT_Y;
		i_zn0 <= (others => '0'); 
	elsif (var_regi = "10") then
		i_xn0 <= o_adder_x;
		i_yn0 <= o_adder_y;
		i_zn0 <= o_adder_z; 
	end if;

------------ \Save to regi ---------		


------------ Set the output ---------
--o_z <= i_zn0 when var_done = '1';
	if (var_done = '1') then
		o_y <= i_yn0;
		o_done <= var_done;
	end if;
------------ \Set the output ---------  
	end if;
end process;
------------ \Set the clock ---------  
clk_2 <= clk_in;
end behave;



